---
layout: 1.4/layout
version: 1.4
group: introduction
title: 概要
nav_order: 1
hash: 1812ea14091c4c83bc23c83be2b8597304398498
---
# 概要

Phoenixは、サーバー側のModel View Controller（MVC）パターンを実装するElixir製のWeb開発フレームワークです。 そのコンポーネントと概念の多くは、Ruby on RailsやPythonのDjangoのような他のWebフレームワークの経験がある私たちにとっては馴染みのあるものです。

Phoenixは、「開発者の高い生産性」と「高いアプリケーションパフォーマンス」を両立します。 また、リアルタイム機能を実装するためのチャネルや、非常に高速なプリコンパイル済みテンプレートなど、いくつかの興味深い新しい工夫が施されています。

すでにElixirに精通している場合は、それはすばらしいことです！そうでない場合は、学ぶべき場所がいくつかあります。 [Elixirガイド](https://elixir-lang.org/getting-started/introduction.html)と[Elixir学習リソースページ](https://elixir-lang.org/learning.html)は学び始めるのにうってつけの場所です。 また、[Phoenixと、Phoenixが依存するプロジェクトについて学ぶ](learning.html)のに役立つリソースのリストもあります。

この入門ガイドの目的は、簡潔で高いレベルのPhoenixの概要、それらを構成する部品、およびそれをサポートする下のレイヤーを提示することです。

これらのガイドをEPUBとして読みたい場合、[こちらをクリックしてください!](https://hexdocs.pm/phoenix/Phoenix.epub)

### Phoenix

Phoenixはいくつかの別個の部分で構成されており、それぞれがWebアプリケーションを構築する際に独自の目的と役割を持ちます。これらのガイド全体で詳細に説明しますが、ここでは簡単に説明します。

- [Endpoint](../endpoint.html)
   - リクエストのライフサイクルを開始および終了します
   - ルーターが引き継ぐまでのリクエストのすべての側面を処理します
   - すべてのリクエストに適用するPlugのコアセットを提供します
   - 指定したルーターにリクエストを渡します
- [Router](../routing.html)
   - リクエストを解析して、適切なcontroller/actionへ渡します。さらに必要であればパラメータも渡します。
   - リソースへのルーティングパスまたはURLを生成するためのヘルパーを提供します
   - リクエストを通す名前付きPlugを定義します
   - パイプライン: Plugをグルーピングして一連のルーティングに簡単に適用できます
- [Controllers](controllers.html)
   - *action* と呼ばれる関数を提供し、リクエストを処理します
   - actions:
      - データを作成して、ビューに渡します
      - ビューを経由してレンダリングを呼び出します
      - リダイレクトを実行します
 - [Views](../views.html)
   - テンプレートを描画します
   - プレゼンテーション層として振る舞います
   - データを加工するために、テンプレートで利用可能なヘルパー関数を定義します
 - [Templates](../templates.html)
   - レスポンスで得られるコンテンツを含むファイルです
   - レスポンスのための基本的な構造を提供し、動的データに置換することも可能です
   - 事前にコンパイルされ、高速です
 - [Channels](../channels.html)
   - 簡単なリアルタイム通信用のソケットを管理します
   - 持続的な接続と双方向通信が可能という点を除いて、コントローラに類似しています
 - PubSub
   - Channel層の下に存在し、クライアントが*トピック*をサブスクライブできます
   - サードパーティ製のpubsub統合のための基盤となるpubsubアダプタを抽象化します

## Phoenix Layers

私達はPhoenixを構成する部品を取り扱いますが、Phoenix自身が実際にモジュラーと柔軟性を持つように設計されたマルチレイヤシステムの最上位層であることを忘れないことが重要です。他の層として、Cowboy、Plug、およびEctoが含まれます。

### Cowboy

デフォルトでは、Phoenix（およびPlug）で使用されるWebサーバはCowboyです。Phoenixを使用した場合、直接Cowboyと接続するのはまれです。あなたが直接Cowboyを利用する必要がある場合は、[Cowboyのドキュメント](https://ninenines.eu/docs/en/cowboy/2.6/guide/)を参照してください。

### Plug

[Plug](https://hexdocs.pm/plug/)は、Webアプリケーションを構築するために、パーツとして利用可能なモジュールを構築するための仕様です。Plugは、その仕様を構築するための再利用可能なモジュールや関数です。それらはリクエストヘッダの解析やロギングのように、別々の動作を提供します。Plug APIは小型かつ一貫性があるため、パイプラインのように一連の流れで定義して実行できます。さらに、プロジェクト内またはプロジェクト間で再利用できます。

認証からパラメータの前処理、さらにはレンダリングまで、ほとんどの処理でPlugを利用できます。

Phoenixは、全体的にPlugの大きな利点を得ています。ルータとコントローラはとくにそうです。

Plugについてのもっとも重要なことの1つは、最終的にユーザーにアプリケーションコンテンツを届けるHTTPサーバへのアダプタを提供することです。現在、Plugは[99S](http://ninenines.eu/)のLoïc HoguinによってErlangで書かれたWebサーバーである[Cowboy](https://github.com/ninenines/cowboy)のアダプターのみ提供しています。
詳細は、[Plug・ガイド](../plug.html)を見てください。


### Ecto

[Ecto](https://hexdocs.pm/ecto)は、言語に組み込まれたクエリ組み立てツールとデータベースラッパーです。Ectoを使うことで、異なるデータベースへの読み書きやドメインのデータのモデル化、型安全な方法で複雑なクエリの記述、 SQLインジェクションやそれ以上の攻撃からの保護が可能です。

Ectoは、4つの主要な抽象化を中心に構築されています。

* Repo - リポジトリは個々のデータベースへの接続を表します。すべてのデータベース操作はリポジトリを介して行われます。
* Schema - スキーマはデータの定義です。テーブル名やフィールド、さらに各フィールドの型を定義します。スキーマはアソシエーション（リソース間の関係）も定義します。
* Query - クエリはリポジトリとスキーマを結びつけ、エレガントにリポジトリからデータを取得し、スキーマ自身にそれをキャストできます。
* Changeset - チェンジセットは、アプリケーションが利用する前に実行する必要がある処理を宣言します。これらは、型キャスト、バリデーション、およびそれ以上を含みます。

新しいPhoenixアプリケーションは、デフォルトではPostgreSQLのストレージとEctoを使用します。

## これらのガイドについての注意

ガイドに問題を見つけるか、これらのガイドの改善をして助けたい場合は、[Phoenixガイド](https://github.com/phoenixframework/phoenix/tree/master/guides/)を参照してください。IssueとPull Requestは喜んで受け入れています！
